// THIS FILE HAS BEEN AUTOGENERATED. DO NOT EDIT.

/**
 * Nefilter queue for device dlink-cam
 */

// Standard libraries
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <pthread.h>
#include <assert.h>
#include <signal.h>
#include <sys/time.h>
// Custom libraries
#include "nfqueue.h"
#include "packet_utils.h"
#include "rule_utils.h"
// Parsers
#include "parsers/header.h"
#include "parsers/dns.h"

// Constants
#define NUM_INTERACTIONS 1
#define NUM_THREADS 3

interaction_data_t interactions_data[NUM_INTERACTIONS];
pthread_t threads[NUM_THREADS];

dns_map_t *dns_map;  // Domain name to IP address mapping

#ifdef DEBUG
uint16_t accepted_packets = 0;
#endif /* DEBUG */


/**
 * @brief stream-app-external#dns-cam-server-a callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_dns_cam_server_a(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_dns_cam_server_a(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1000\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    // Skip layer 3 and 4 headers
    size_t skipped = get_headers_length(payload);

    // Parse payload as DNS message
    dns_message_t dns_message = dns_parse_message(payload + skipped);
    #ifdef DEBUG
    dns_print_message(dns_message);
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP



    // Policy stream-app-external#dns-cam-server-a
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        (
        interactions_data[0].current_state == 3 ||
        interactions_data[0].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {


        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#dns-cam-server-a: State %hhu -> State 1\n", interactions_data[0].current_state);
        #endif
        interactions_data[0].current_state = 1;

        // Newly added: Add loop support
        interactions_data[0].in_loop = true;
        interactions_data[0].loop_state = 1;
        #ifdef DEBUG
        printf("Entering loop state: %hhu\n", interactions_data[0].loop_state);
        #endif

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-a,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        // Newly added: Additional log for loop state change
        printf(",%ld.%06ld,loop-state-change,enter-loop,state-%hhu\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, interactions_data[0].loop_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#dns-cam-server-a - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));

    // Policy stream-app-external#dns-cam-server-aaaa
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        (
        interactions_data[0].current_state == 1
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {


        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#dns-cam-server-aaaa: State %hhu -> State 2\n", interactions_data[0].current_state);
        #endif
        interactions_data[0].current_state = 2;

        // Newly added: Update loop state
        interactions_data[0].loop_state = 2;
        #ifdef DEBUG
        printf("Advancing loop state: %hhu\n", interactions_data[0].loop_state);
        #endif

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-aaaa,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        // Newly added: Additional log for loop state change
        printf(",%ld.%06ld,loop-state-change,advance-loop,state-%hhu\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, interactions_data[0].loop_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#dns-cam-server-aaaa - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));

    // Free memory allocated for parsed messages
    dns_free_message(dns_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-a,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}




/**
 * @brief stream-app-external#stun-bind-cam-server callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_stun_bind_cam_server(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_stun_bind_cam_server(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1001\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t dst_addr = get_ipv4_dst_addr(payload);  // IPv4 destination address, in network byte order
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP



    // Policy stream-app-external#stun-bind-cam-server
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        (
        interactions_data[0].current_state == 2
        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}, interactions_data[0].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}) )
        )
    ) {


        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#stun-bind-cam-server: State %hhu -> State 3\n", interactions_data[0].current_state);
        #endif
        interactions_data[0].current_state = 3;

        // Newly added: Update loop state
        interactions_data[0].loop_state = 3;
        #ifdef DEBUG
        printf("Advancing to final loop state: %hhu\n", interactions_data[0].loop_state);
        #endif

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        // Additional log for loop state change
        printf(",%ld.%06ld,loop-state-change,final-loop-state,state-%hhu\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, interactions_data[0].loop_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#stun-bind-cam-server - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}




/**
 * @brief stream-app-external#udp-stream-wan callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_udp_stream_wan(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_udp_stream_wan(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1002\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP



    // Policy stream-app-external#udp-stream-wan
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        (
        interactions_data[0].current_state == 3
        )
    ) {

        
        // Newly added: Check if we're in a loop and need to exit
        if (interactions_data[0].in_loop) {
            interactions_data[0].in_loop = false;
            interactions_data[0].loop_state = 0;
            #ifdef DEBUG
            printf("Exiting loop and entering UDP stream state\n");
            #endif
            #ifdef LOG
            // Newly added: Additional log for loop state change
            printf(",%ld.%06ld,loop-state-change,exit-loop,udp-stream\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
            #endif /* LOG */
        }

        // Policy is periodic
        #ifdef DEBUG
        printf("stream-app-external#udp-stream-wan: State %hhu\n", interactions_data[0].current_state);
        #endif

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#udp-stream-wan - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief SIGINT handler, flush stdout and exit.
 *
 * @param arg unused
 */
void sigint_handler(int arg) {
    fflush(stdout);
    exit(0);
}

/**
 * @brief Program entry point
 * 
 * @param argc number of command line arguments
 * @param argv list of command line arguments
 * @return exit code, 0 if success
 */
int main(int argc, char const *argv[]) {

    // Setup SIGINT handler
    signal(SIGINT, sigint_handler);

    #ifdef LOG
    // CSV log file header
    printf("hash,timestamp,policy,state,verdict\n");
    #endif /* LOG */

    /* GLOBAL STRUCTURES INITIALIZATION */

    // Initialize DNS map
    dns_map = dns_map_create();


    /* INTERACTION DATA INITIALIZATION */

    int ret = 0;  // Return code for various functions
    interactions_data[0].nfq_id_base = 1000;
    interactions_data[0].num_policies = 4;
    interactions_data[0].num_states = 4;
    ret = pthread_mutex_init(&(interactions_data[0].mutex), NULL);
    assert(ret == 0);
    interactions_data[0].current_state = 0;
    interactions_data[0].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[0].counters = (counters_t *) malloc(sizeof(counters_t) * 4);
    assert(interactions_data[0].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 4; i++) {
        (interactions_data[0].counters + i)->packet_count.is_initialized = false;
        (interactions_data[0].counters + i)->duration.is_initialized = false;
    }
    // Newly added: Initialize loop-related fields
    interactions_data[0].in_loop = false;     // Initially not in loop
    interactions_data[0].loop_state = 0;      // Initial loop state
    interactions_data[0].next_after_loop = 3; // State to enter after loop (UDP stream state)


    
    /* NFQUEUE THREADS LAUNCH */

    // Create threads
    uint8_t i = 0;

    // stream_app_external_dns_cam_server_a
    thread_arg_t thread_arg_stream_app_external_dns_cam_server_a = {
        .queue_id = 1000,
        .func = &callback_stream_app_external_dns_cam_server_a,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_dns_cam_server_a);
    assert(ret == 0);
    
    // stream_app_external_stun_bind_cam_server
    thread_arg_t thread_arg_stream_app_external_stun_bind_cam_server = {
        .queue_id = 1001,
        .func = &callback_stream_app_external_stun_bind_cam_server,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_stun_bind_cam_server);
    assert(ret == 0);
    
    // stream_app_external_udp_stream_wan
    thread_arg_t thread_arg_stream_app_external_udp_stream_wan = {
        .queue_id = 1002,
        .func = &callback_stream_app_external_udp_stream_wan,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_udp_stream_wan);
    assert(ret == 0);
    
    // Wait forever for threads
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }


    /* FREE MEMORY */

    // Free interactions data
    for (uint8_t i = 0; i < NUM_INTERACTIONS; i++) {
        free(interactions_data[i].counters);
        pthread_mutex_destroy(&(interactions_data[i].mutex));
    }

    // Free DNS map
    dns_map_free(dns_map);

    return 0;
}
