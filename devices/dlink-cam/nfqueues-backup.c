// THIS FILE HAS BEEN AUTOGENERATED. DO NOT EDIT.

/**
 * Nefilter queue for device dlink-cam
 */

// Standard libraries
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <pthread.h>
#include <assert.h>
#include <signal.h>
#include <sys/time.h>
// Custom libraries
#include "nfqueue.h"
#include "packet_utils.h"
#include "rule_utils.h"
// Parsers
#include "parsers/header.h"
#include "parsers/dns.h"
#include "parsers/http.h"
#include "parsers/dhcp.h"
#include "parsers/dns.h"
#include "parsers/igmp.h"

// Constants
#define NUM_INTERACTIONS 18
#define NUM_THREADS 26

interaction_data_t interactions_data[NUM_INTERACTIONS];
pthread_t threads[NUM_THREADS];

dns_map_t *dns_map;  // Domain name to IP address mapping

#ifdef DEBUG
uint16_t accepted_packets = 0;
#endif /* DEBUG */
/**
 * @brief single#dns-ipv4 callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_single_dns_ipv4(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_single_dns_ipv4(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1000\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    // Skip layer 3 and 4 headers
    size_t skipped = get_headers_length(payload);

    // Parse payload as DNS message
    dns_message_t dns_message = dns_parse_message(payload + skipped);
    #ifdef DEBUG
    dns_print_message(dns_message);
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy single#dns-ipv4
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        ( 
        interactions_data[0].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        (
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        ||
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        )
        &&
        (
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "ca-mgr.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas-1.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-dcdda.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-us-sas.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-fwd.auto.mydlink.com")
        )
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("single#dns-ipv4: State %hhu -> State 1\n", interactions_data[0].current_state);
        #endif
        interactions_data[0].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,single#dns-ipv4,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: single#dns-ipv4 - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));
    // Policy bootstrap-stream-wan#dns-cam-sas-1-a
    pthread_mutex_lock(&(interactions_data[10].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[10].current_state;
    #endif
    if (
        ( 
        interactions_data[10].current_state == 5 ||
        interactions_data[10].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas-1.auto.mydlink.com")
        )
    ) {

        // Previous policy was transient
        // Reset packet counter
        (interactions_data[10].counters + 4)->packet_count.value = 0;
        #ifdef DEBUG
        printf("Reset packet-count counter for interaction 10 and policy 4\n");
        #endif
        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("bootstrap-stream-wan#dns-cam-sas-1-a: State %hhu -> State 1\n", interactions_data[10].current_state);
        #endif
        interactions_data[10].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,bootstrap-stream-wan#dns-cam-sas-1-a,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: bootstrap-stream-wan#dns-cam-sas-1-a - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[10].mutex));
    // Policy bootstrap-stream-wan#dns-cam-sas-1-aaaa
    pthread_mutex_lock(&(interactions_data[10].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[10].current_state;
    #endif
    if (
        ( 
        interactions_data[10].current_state == 2
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas-1.auto.mydlink.com")
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("bootstrap-stream-wan#dns-cam-sas-1-aaaa: State %hhu -> State 3\n", interactions_data[10].current_state);
        #endif
        interactions_data[10].current_state = 3;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,bootstrap-stream-wan#dns-cam-sas-1-aaaa,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: bootstrap-stream-wan#dns-cam-sas-1-aaaa - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[10].mutex));
    // Policy http-head-boot#dns-cam-ca-mgr
    pthread_mutex_lock(&(interactions_data[12].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[12].current_state;
    #endif
    if (
        ( 
        interactions_data[12].current_state == 3 ||
        interactions_data[12].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "ca-mgr.auto.mydlink.com")
        )
    ) {

        // Previous policy was transient
        // Reset packet counter
        (interactions_data[12].counters + 2)->packet_count.value = 0;
        #ifdef DEBUG
        printf("Reset packet-count counter for interaction 12 and policy 2\n");
        #endif
        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("http-head-boot#dns-cam-ca-mgr: State %hhu -> State 1\n", interactions_data[12].current_state);
        #endif
        interactions_data[12].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,http-head-boot#dns-cam-ca-mgr,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: http-head-boot#dns-cam-ca-mgr - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[12].mutex));
    // Policy https-boot-cam-fwd#dns-cam-fwd
    pthread_mutex_lock(&(interactions_data[13].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[13].current_state;
    #endif
    if (
        ( 
        interactions_data[13].current_state == 3 ||
        interactions_data[13].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-fwd.auto.mydlink.com")
        )
    ) {

        // Previous policy was transient
        // Reset packet counter
        (interactions_data[13].counters + 2)->packet_count.value = 0;
        #ifdef DEBUG
        printf("Reset packet-count counter for interaction 13 and policy 2\n");
        #endif
        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("https-boot-cam-fwd#dns-cam-fwd: State %hhu -> State 1\n", interactions_data[13].current_state);
        #endif
        interactions_data[13].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,https-boot-cam-fwd#dns-cam-fwd,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: https-boot-cam-fwd#dns-cam-fwd - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[13].mutex));
    // Policy https-dcdda#dns-cam-dcdda
    pthread_mutex_lock(&(interactions_data[14].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[14].current_state;
    #endif
    if (
        ( 
        interactions_data[14].current_state == 2 ||
        interactions_data[14].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-dcdda.auto.mydlink.com")
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("https-dcdda#dns-cam-dcdda: State %hhu -> State 1\n", interactions_data[14].current_state);
        #endif
        interactions_data[14].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,https-dcdda#dns-cam-dcdda,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: https-dcdda#dns-cam-dcdda - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[14].mutex));
    // Policy stream-app-external#dns-cam-server-a
    pthread_mutex_lock(&(interactions_data[15].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[15].current_state;
    #endif
    if (
        ( 
        (
        interactions_data[15].in_loop && 
        interactions_data[15].current_state == 6
        ) ||
        interactions_data[15].current_state == 6 ||
        interactions_data[15].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {
        // Enter loop, update loop state
        interactions_data[15].in_loop = true;

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#dns-cam-server-a: State %hhu -> State 1\n", interactions_data[15].current_state);
        #endif
        interactions_data[15].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-a,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#dns-cam-server-a - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[15].mutex));
    // Policy stream-app-external#dns-cam-server-aaaa
    pthread_mutex_lock(&(interactions_data[15].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[15].current_state;
    #endif
    if (
        ( 
        interactions_data[15].current_state == 2
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#dns-cam-server-aaaa: State %hhu -> State 3\n", interactions_data[15].current_state);
        #endif
        interactions_data[15].current_state = 3;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-aaaa,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#dns-cam-server-aaaa - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[15].mutex));
    // Policy stream-app-local#dns-cam-server-a
    pthread_mutex_lock(&(interactions_data[16].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[16].current_state;
    #endif
    if (
        ( 
        interactions_data[16].current_state == 6 ||
        interactions_data[16].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-local#dns-cam-server-a: State %hhu -> State 1\n", interactions_data[16].current_state);
        #endif
        interactions_data[16].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#dns-cam-server-a,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-local#dns-cam-server-a - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[16].mutex));
    // Policy stream-app-local#dns-cam-server-aaaa
    pthread_mutex_lock(&(interactions_data[16].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[16].current_state;
    #endif
    if (
        ( 
        interactions_data[16].current_state == 2
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-local#dns-cam-server-aaaa: State %hhu -> State 3\n", interactions_data[16].current_state);
        #endif
        interactions_data[16].current_state = 3;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#dns-cam-server-aaaa,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-local#dns-cam-server-aaaa - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[16].mutex));
    // Policy websocket-sas-1#dns-cam-sas-1
    pthread_mutex_lock(&(interactions_data[17].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[17].current_state;
    #endif
    if (
        ( 
        interactions_data[17].current_state == 2 ||
        interactions_data[17].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas-1.auto.mydlink.com")
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("websocket-sas-1#dns-cam-sas-1: State %hhu -> State 1\n", interactions_data[17].current_state);
        #endif
        interactions_data[17].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,websocket-sas-1#dns-cam-sas-1,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: websocket-sas-1#dns-cam-sas-1 - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[17].mutex));

    // Free memory allocated for parsed messages
    dns_free_message(dns_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,single#dns-ipv4,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief single#dns-ipv4-backward callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_single_dns_ipv4_backward(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_single_dns_ipv4_backward(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1001\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    // Skip layer 3 and 4 headers
    size_t skipped = get_headers_length(payload);

    // Parse payload as DNS message
    dns_message_t dns_message = dns_parse_message(payload + skipped);
    #ifdef DEBUG
    dns_print_message(dns_message);
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy single#dns-ipv4-backward
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        ( 
        interactions_data[0].current_state == 1
        )
        && (
        dns_message.header.qr == 1
        &&
        (
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        ||
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        )
        &&
        (
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "ca-mgr.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas-1.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-dcdda.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-us-sas.auto.mydlink.com")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-fwd.auto.mydlink.com")
        )
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        if (dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "ca-mgr.auto.mydlink.com")) {
            domain_name = "ca-mgr.auto.mydlink.com";
            ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);
        }
        else if (dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")) {
            domain_name = "mp-eu-sas.auto.mydlink.com";
            ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);
        }
        else if (dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas-1.auto.mydlink.com")) {
            domain_name = "mp-eu-sas-1.auto.mydlink.com";
            ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);
        }
        else if (dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-dcdda.auto.mydlink.com")) {
            domain_name = "mp-eu-dcdda.auto.mydlink.com";
            ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);
        }
        else if (dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-us-sas.auto.mydlink.com")) {
            domain_name = "mp-us-sas.auto.mydlink.com";
            ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);
        }
        else if (dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-fwd.auto.mydlink.com")) {
            domain_name = "mp-eu-fwd.auto.mydlink.com";
            ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);
        }

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("single#dns-ipv4-backward: State %hhu -> State 0\n", interactions_data[0].current_state);
        #endif
        interactions_data[0].current_state = 0;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[0].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,single#dns-ipv4-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: single#dns-ipv4-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));
    // Policy bootstrap-stream-wan#dns-cam-sas-1-a-backward
    pthread_mutex_lock(&(interactions_data[10].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[10].current_state;
    #endif
    if (
        ( 
        interactions_data[10].current_state == 1
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas-1.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-sas-1.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("bootstrap-stream-wan#dns-cam-sas-1-a-backward: State %hhu -> State 2\n", interactions_data[10].current_state);
        #endif
        interactions_data[10].current_state = 2;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[10].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,bootstrap-stream-wan#dns-cam-sas-1-a-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: bootstrap-stream-wan#dns-cam-sas-1-a-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[10].mutex));
    // Policy bootstrap-stream-wan#dns-cam-sas-1-aaaa-backward
    pthread_mutex_lock(&(interactions_data[10].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[10].current_state;
    #endif
    if (
        ( 
        interactions_data[10].current_state == 3
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas-1.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-sas-1.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("bootstrap-stream-wan#dns-cam-sas-1-aaaa-backward: State %hhu -> State 4\n", interactions_data[10].current_state);
        #endif
        interactions_data[10].current_state = 4;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[10].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,bootstrap-stream-wan#dns-cam-sas-1-aaaa-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: bootstrap-stream-wan#dns-cam-sas-1-aaaa-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[10].mutex));
    // Policy http-head-boot#dns-cam-ca-mgr-backward
    pthread_mutex_lock(&(interactions_data[12].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[12].current_state;
    #endif
    if (
        ( 
        interactions_data[12].current_state == 1
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "ca-mgr.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "ca-mgr.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("http-head-boot#dns-cam-ca-mgr-backward: State %hhu -> State 2\n", interactions_data[12].current_state);
        #endif
        interactions_data[12].current_state = 2;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[12].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,http-head-boot#dns-cam-ca-mgr-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: http-head-boot#dns-cam-ca-mgr-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[12].mutex));
    // Policy https-boot-cam-fwd#dns-cam-fwd-backward
    pthread_mutex_lock(&(interactions_data[13].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[13].current_state;
    #endif
    if (
        ( 
        interactions_data[13].current_state == 1
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-fwd.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-fwd.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("https-boot-cam-fwd#dns-cam-fwd-backward: State %hhu -> State 2\n", interactions_data[13].current_state);
        #endif
        interactions_data[13].current_state = 2;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[13].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,https-boot-cam-fwd#dns-cam-fwd-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: https-boot-cam-fwd#dns-cam-fwd-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[13].mutex));
    // Policy https-dcdda#dns-cam-dcdda-backward
    pthread_mutex_lock(&(interactions_data[14].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[14].current_state;
    #endif
    if (
        ( 
        interactions_data[14].current_state == 1
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-dcdda.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-dcdda.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("https-dcdda#dns-cam-dcdda-backward: State %hhu -> State 2\n", interactions_data[14].current_state);
        #endif
        interactions_data[14].current_state = 2;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[14].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,https-dcdda#dns-cam-dcdda-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: https-dcdda#dns-cam-dcdda-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[14].mutex));
    // Policy stream-app-external#dns-cam-server-a-backward
    pthread_mutex_lock(&(interactions_data[15].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[15].current_state;
    #endif
    if (
        ( 
        interactions_data[15].current_state == 1
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-sas.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#dns-cam-server-a-backward: State %hhu -> State 2\n", interactions_data[15].current_state);
        #endif
        interactions_data[15].current_state = 2;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[15].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-a-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#dns-cam-server-a-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[15].mutex));
    // Policy stream-app-external#dns-cam-server-aaaa-backward
    pthread_mutex_lock(&(interactions_data[15].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[15].current_state;
    #endif
    if (
        ( 
        interactions_data[15].current_state == 3
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-sas.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#dns-cam-server-aaaa-backward: State %hhu -> State 4\n", interactions_data[15].current_state);
        #endif
        interactions_data[15].current_state = 4;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[15].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-aaaa-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#dns-cam-server-aaaa-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[15].mutex));
    // Policy stream-app-local#dns-cam-server-a-backward
    pthread_mutex_lock(&(interactions_data[16].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[16].current_state;
    #endif
    if (
        ( 
        interactions_data[16].current_state == 1
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-sas.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-local#dns-cam-server-a-backward: State %hhu -> State 2\n", interactions_data[16].current_state);
        #endif
        interactions_data[16].current_state = 2;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[16].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#dns-cam-server-a-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-local#dns-cam-server-a-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[16].mutex));
    // Policy stream-app-local#dns-cam-server-aaaa-backward
    pthread_mutex_lock(&(interactions_data[16].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[16].current_state;
    #endif
    if (
        ( 
        interactions_data[16].current_state == 3
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-sas.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-local#dns-cam-server-aaaa-backward: State %hhu -> State 4\n", interactions_data[16].current_state);
        #endif
        interactions_data[16].current_state = 4;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[16].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#dns-cam-server-aaaa-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-local#dns-cam-server-aaaa-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[16].mutex));
    // Policy websocket-sas-1#dns-cam-sas-1-backward
    pthread_mutex_lock(&(interactions_data[17].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[17].current_state;
    #endif
    if (
        ( 
        interactions_data[17].current_state == 1
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas-1.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-sas-1.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("websocket-sas-1#dns-cam-sas-1-backward: State %hhu -> State 2\n", interactions_data[17].current_state);
        #endif
        interactions_data[17].current_state = 2;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[17].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,websocket-sas-1#dns-cam-sas-1-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: websocket-sas-1#dns-cam-sas-1-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[17].mutex));

    // Free memory allocated for parsed messages
    dns_free_message(dns_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,single#dns-ipv4-backward,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief single#igmp-join-mdns callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_single_igmp_join_mdns(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_single_igmp_join_mdns(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1010\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    // Skip layer 3 and 4 headers
    size_t skipped = get_headers_length(payload);

    // Parse payload as IGMP message
    igmp_message_t igmp_message = igmp_parse_message(payload + skipped);
    #ifdef DEBUG
    igmp_print_message(igmp_message);
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy single#igmp-join-mdns
    pthread_mutex_lock(&(interactions_data[1].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[1].current_state;
    #endif
    if (
        igmp_message.type == V3_MEMBERSHIP_REPORT
        &&
        strcmp(ipv4_net_to_str((igmp_message.body.v3_membership_report.groups)->group_address), "224.0.0.251") == 0
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,single#igmp-join-mdns,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: single#igmp-join-mdns - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[1].mutex));

    // Free memory allocated for parsed messages
    igmp_free_message(igmp_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,single#igmp-join-mdns,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief single#mdns-query-any callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_single_mdns_query_any(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_single_mdns_query_any(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1020\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    // Skip layer 3 and 4 headers
    size_t skipped = get_headers_length(payload);

    // Parse payload as DNS message
    dns_message_t dns_message = dns_parse_message(payload + skipped);
    #ifdef DEBUG
    dns_print_message(dns_message);
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy single#mdns-query-any
    pthread_mutex_lock(&(interactions_data[2].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[2].current_state;
    #endif
    if (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == ANY )
        &&
        (
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "DCS-8000LH-B0C554435483.local")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "DCS-8000LH-5483._http._tcp.local")
        ||
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "DCS-8000LH-5483._dcp._tcp.local")
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,single#mdns-query-any,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: single#mdns-query-any - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[2].mutex));
    // Policy single#mdns-query-ptr
    pthread_mutex_lock(&(interactions_data[3].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[3].current_state;
    #endif
    if (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == PTR )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "_dcp._tcp.local")
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,single#mdns-query-ptr,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: single#mdns-query-ptr - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[3].mutex));
    // Policy single#mdns-response
    pthread_mutex_lock(&(interactions_data[4].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[4].current_state;
    #endif
    if (
        dns_message.header.qr == 1
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,single#mdns-response,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: single#mdns-response - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[4].mutex));

    // Free memory allocated for parsed messages
    dns_free_message(dns_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,single#mdns-query-any,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief arp-cam-gateway#arp-reply-gateway-cam callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_arp_cam_gateway_arp_reply_gateway_cam(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_arp_cam_gateway_arp_reply_gateway_cam(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1030\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy arp-cam-gateway#arp-reply-gateway-cam
    pthread_mutex_lock(&(interactions_data[6].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[6].current_state;
    #endif
    if (
        ( 
        interactions_data[6].current_state == 0
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("arp-cam-gateway#arp-reply-gateway-cam: State %hhu -> State 1\n", interactions_data[6].current_state);
        #endif
        interactions_data[6].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,arp-cam-gateway#arp-reply-gateway-cam,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: arp-cam-gateway#arp-reply-gateway-cam - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[6].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,arp-cam-gateway#arp-reply-gateway-cam,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief arp-cam-gateway#arp-request-cam-gateway callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_arp_cam_gateway_arp_request_cam_gateway(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_arp_cam_gateway_arp_request_cam_gateway(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1031\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy arp-cam-gateway#arp-request-cam-gateway
    pthread_mutex_lock(&(interactions_data[6].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[6].current_state;
    #endif
    if (
        ( 
        interactions_data[6].current_state == 1
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("arp-cam-gateway#arp-request-cam-gateway: State %hhu -> State 0\n", interactions_data[6].current_state);
        #endif
        interactions_data[6].current_state = 0;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,arp-cam-gateway#arp-request-cam-gateway,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: arp-cam-gateway#arp-request-cam-gateway - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[6].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,arp-cam-gateway#arp-request-cam-gateway,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief arp-camera-phone#arp-reply-phone-cam callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_arp_camera_phone_arp_reply_phone_cam(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_arp_camera_phone_arp_reply_phone_cam(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1040\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy arp-camera-phone#arp-reply-phone-cam
    pthread_mutex_lock(&(interactions_data[7].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[7].current_state;
    #endif
    if (
        ( 
        interactions_data[7].current_state == 0
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("arp-camera-phone#arp-reply-phone-cam: State %hhu -> State 1\n", interactions_data[7].current_state);
        #endif
        interactions_data[7].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,arp-camera-phone#arp-reply-phone-cam,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: arp-camera-phone#arp-reply-phone-cam - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[7].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,arp-camera-phone#arp-reply-phone-cam,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief arp-camera-phone#arp-request-cam-phone callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_arp_camera_phone_arp_request_cam_phone(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_arp_camera_phone_arp_request_cam_phone(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1041\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy arp-camera-phone#arp-request-cam-phone
    pthread_mutex_lock(&(interactions_data[7].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[7].current_state;
    #endif
    if (
        ( 
        interactions_data[7].current_state == 1
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("arp-camera-phone#arp-request-cam-phone: State %hhu -> State 0\n", interactions_data[7].current_state);
        #endif
        interactions_data[7].current_state = 0;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,arp-camera-phone#arp-request-cam-phone,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: arp-camera-phone#arp-request-cam-phone - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[7].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,arp-camera-phone#arp-request-cam-phone,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief arp-gateway-cam#arp-reply-cam-gateway callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_arp_gateway_cam_arp_reply_cam_gateway(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_arp_gateway_cam_arp_reply_cam_gateway(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1050\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy arp-gateway-cam#arp-reply-cam-gateway
    pthread_mutex_lock(&(interactions_data[8].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[8].current_state;
    #endif
    if (
        ( 
        interactions_data[8].current_state == 1 ||
        interactions_data[8].current_state == 0
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("arp-gateway-cam#arp-reply-cam-gateway: State %hhu -> State 1\n", interactions_data[8].current_state);
        #endif
        interactions_data[8].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,arp-gateway-cam#arp-reply-cam-gateway,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: arp-gateway-cam#arp-reply-cam-gateway - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[8].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,arp-gateway-cam#arp-reply-cam-gateway,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief arp-gateway-cam#arp-request-gateway-cam callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_arp_gateway_cam_arp_request_gateway_cam(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_arp_gateway_cam_arp_request_gateway_cam(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1051\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy arp-gateway-cam#arp-request-gateway-cam
    pthread_mutex_lock(&(interactions_data[8].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[8].current_state;
    #endif
    if (
        ( 
        interactions_data[8].current_state == 1
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,arp-gateway-cam#arp-request-gateway-cam,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: arp-gateway-cam#arp-request-gateway-cam - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[8].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,arp-gateway-cam#arp-request-gateway-cam,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief arp-phone-camera#arp-reply-cam-phone callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_arp_phone_camera_arp_reply_cam_phone(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_arp_phone_camera_arp_reply_cam_phone(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1060\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy arp-phone-camera#arp-reply-cam-phone
    pthread_mutex_lock(&(interactions_data[9].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[9].current_state;
    #endif
    if (
        ( 
        interactions_data[9].current_state == 1 ||
        interactions_data[9].current_state == 0
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("arp-phone-camera#arp-reply-cam-phone: State %hhu -> State 1\n", interactions_data[9].current_state);
        #endif
        interactions_data[9].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,arp-phone-camera#arp-reply-cam-phone,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: arp-phone-camera#arp-reply-cam-phone - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[9].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,arp-phone-camera#arp-reply-cam-phone,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief arp-phone-camera#arp-request-phone-cam callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_arp_phone_camera_arp_request_phone_cam(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_arp_phone_camera_arp_request_phone_cam(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1061\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy arp-phone-camera#arp-request-phone-cam
    pthread_mutex_lock(&(interactions_data[9].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[9].current_state;
    #endif
    if (
        ( 
        interactions_data[9].current_state == 1
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,arp-phone-camera#arp-request-phone-cam,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: arp-phone-camera#arp-request-phone-cam - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[9].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,arp-phone-camera#arp-request-phone-cam,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief bootstrap-stream-wan#http-relay-cam-sas-1 callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_bootstrap_stream_wan_http_relay_cam_sas_1(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_bootstrap_stream_wan_http_relay_cam_sas_1(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1070\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t dst_addr = get_ipv4_dst_addr(payload);  // IPv4 destination address, in network byte order
    // Skip layer 3 and 4 headers
    size_t l3_header_length = get_l3_header_length(payload);
    uint16_t dst_port = get_dst_port(payload + l3_header_length);
    size_t skipped = get_headers_length(payload);
    bool has_payload = pkt_len - skipped >= HTTP_MESSAGE_MIN_LEN;
    bool is_http_message = has_payload && is_http(payload + skipped);

    // Parse payload as HTTP message
    http_message_t http_message = http_parse_message(payload + skipped, dst_port);
    #ifdef DEBUG
    if (is_http_message) {
        http_print_message(http_message);
    } else {
        printf("TCP message with destination port %hu corresponding to HTTP traffic.\n", dst_port);
    }
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP

    // Initialize packet count if not initialized yet
    if (!(interactions_data[10].counters + 4)->packet_count.is_initialized) {
        (interactions_data[10].counters + 4)->packet_count.value = 0;
        (interactions_data[10].counters + 4)->packet_count.is_initialized = true;
    }
    // Initialize packet count if not initialized yet
    if (!(interactions_data[12].counters + 2)->packet_count.is_initialized) {
        (interactions_data[12].counters + 2)->packet_count.value = 0;
        (interactions_data[12].counters + 2)->packet_count.is_initialized = true;
    }

    // Policy bootstrap-stream-wan#http-relay-cam-sas-1
    pthread_mutex_lock(&(interactions_data[10].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[10].current_state;
    #endif
    if (
        (interactions_data[10].counters + 4)->packet_count.is_initialized &&
        ( 
        interactions_data[10].current_state == 4 ||
        interactions_data[10].current_state == 5
        )
        && (
        !is_http_message || (
        http_message.is_request
        &&
        http_message.method == HTTP_GET
        &&
        strncmp(http_message.uri, "/relay", 7) == 0
        &&
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}, interactions_data[10].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas-1.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}) )
        )
        )
    ) {

        // Policy is transient, increment state to indicate the transient policy is ongoing
        #ifdef DEBUG
        printf("bootstrap-stream-wan#http-relay-cam-sas-1: State %hhu -> State 5\n", interactions_data[10].current_state);
        #endif
        interactions_data[10].current_state = 5;
        // Increment packet count
        (interactions_data[10].counters + 4)->packet_count.value++;
        if (
            (interactions_data[10].counters + 4)->packet_count.value >= 15
        ) {
            // Policy is transient and counters have been reached
            // Increment state to indicate the transient policy is over
            #ifdef DEBUG
            printf("bootstrap-stream-wan#http-relay-cam-sas-1: State %hhu -> State 0\n", interactions_data[10].current_state);
            #endif
            interactions_data[10].current_state = 0;
            (interactions_data[10].counters + 4)->packet_count.is_initialized = false;
        }


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,bootstrap-stream-wan#http-relay-cam-sas-1,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: bootstrap-stream-wan#http-relay-cam-sas-1 - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[10].mutex));
    // Policy http-head-boot#http-head-cam-cloud
    pthread_mutex_lock(&(interactions_data[12].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[12].current_state;
    #endif
    if (
        (interactions_data[12].counters + 2)->packet_count.is_initialized &&
        ( 
        interactions_data[12].current_state == 2 ||
        interactions_data[12].current_state == 3
        )
        && (
        !is_http_message || (
        http_message.is_request
        &&
        http_message.method == HTTP_HEAD
        &&
        strncmp(http_message.uri, "/default/ca-bundle.crt", 23) == 0
        &&
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}, interactions_data[12].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "ca-mgr.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}) )
        )
        )
    ) {

        // Policy is transient, increment state to indicate the transient policy is ongoing
        #ifdef DEBUG
        printf("http-head-boot#http-head-cam-cloud: State %hhu -> State 3\n", interactions_data[12].current_state);
        #endif
        interactions_data[12].current_state = 3;
        // Increment packet count
        (interactions_data[12].counters + 2)->packet_count.value++;
        if (
            (interactions_data[12].counters + 2)->packet_count.value >= 15
        ) {
            // Policy is transient and counters have been reached
            // Increment state to indicate the transient policy is over
            #ifdef DEBUG
            printf("http-head-boot#http-head-cam-cloud: State %hhu -> State 0\n", interactions_data[12].current_state);
            #endif
            interactions_data[12].current_state = 0;
            (interactions_data[12].counters + 2)->packet_count.is_initialized = false;
        }


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,http-head-boot#http-head-cam-cloud,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: http-head-boot#http-head-cam-cloud - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[12].mutex));
    // Policy websocket-sas-1#websocket-cam-sas-1
    pthread_mutex_lock(&(interactions_data[17].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[17].current_state;
    #endif
    if (
        ( 
        interactions_data[17].current_state == 2        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}, interactions_data[17].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas-1.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}) )
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,websocket-sas-1#websocket-cam-sas-1,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: websocket-sas-1#websocket-cam-sas-1 - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[17].mutex));

    // Free memory allocated for parsed messages
    http_free_message(http_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,bootstrap-stream-wan#http-relay-cam-sas-1,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief bootstrap-stream-wan#http-relay-cam-sas-1-backward callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_bootstrap_stream_wan_http_relay_cam_sas_1_backward(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_bootstrap_stream_wan_http_relay_cam_sas_1_backward(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1071\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t src_addr = get_ipv4_src_addr(payload);  // IPv4 source address, in network byte order
    // Skip layer 3 and 4 headers
    size_t l3_header_length = get_l3_header_length(payload);
    uint16_t dst_port = get_dst_port(payload + l3_header_length);
    size_t skipped = get_headers_length(payload);
    bool has_payload = pkt_len - skipped >= HTTP_MESSAGE_MIN_LEN;
    bool is_http_message = has_payload && is_http(payload + skipped);

    // Parse payload as HTTP message
    http_message_t http_message = http_parse_message(payload + skipped, dst_port);
    #ifdef DEBUG
    if (is_http_message) {
        http_print_message(http_message);
    } else {
        printf("TCP message with destination port %hu corresponding to HTTP traffic.\n", dst_port);
    }
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy bootstrap-stream-wan#http-relay-cam-sas-1-backward
    pthread_mutex_lock(&(interactions_data[10].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[10].current_state;
    #endif
    if (
        (interactions_data[10].counters + 4)->packet_count.is_initialized &&
        ( 
        interactions_data[10].current_state == 4 ||
        interactions_data[10].current_state == 5
        )
        && (
        !is_http_message || (
        !http_message.is_request
        &&
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = src_addr}, interactions_data[10].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas-1.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = src_addr}) )
        )
        )
    ) {

        // Policy is transient, increment state to indicate the transient policy is ongoing
        #ifdef DEBUG
        printf("bootstrap-stream-wan#http-relay-cam-sas-1-backward: State %hhu -> State 5\n", interactions_data[10].current_state);
        #endif
        interactions_data[10].current_state = 5;
        // Increment packet count
        (interactions_data[10].counters + 4)->packet_count.value++;
        if (
            (interactions_data[10].counters + 4)->packet_count.value >= 15
        ) {
            // Policy is transient and counters have been reached
            // Increment state to indicate the transient policy is over
            #ifdef DEBUG
            printf("bootstrap-stream-wan#http-relay-cam-sas-1-backward: State %hhu -> State 0\n", interactions_data[10].current_state);
            #endif
            interactions_data[10].current_state = 0;
            (interactions_data[10].counters + 4)->packet_count.is_initialized = false;
        }


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,bootstrap-stream-wan#http-relay-cam-sas-1-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: bootstrap-stream-wan#http-relay-cam-sas-1-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[10].mutex));
    // Policy http-head-boot#http-head-cam-cloud-backward
    pthread_mutex_lock(&(interactions_data[12].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[12].current_state;
    #endif
    if (
        (interactions_data[12].counters + 2)->packet_count.is_initialized &&
        ( 
        interactions_data[12].current_state == 2 ||
        interactions_data[12].current_state == 3
        )
        && (
        !is_http_message || (
        !http_message.is_request
        &&
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = src_addr}, interactions_data[12].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "ca-mgr.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = src_addr}) )
        )
        )
    ) {

        // Policy is transient, increment state to indicate the transient policy is ongoing
        #ifdef DEBUG
        printf("http-head-boot#http-head-cam-cloud-backward: State %hhu -> State 3\n", interactions_data[12].current_state);
        #endif
        interactions_data[12].current_state = 3;
        // Increment packet count
        (interactions_data[12].counters + 2)->packet_count.value++;
        if (
            (interactions_data[12].counters + 2)->packet_count.value >= 15
        ) {
            // Policy is transient and counters have been reached
            // Increment state to indicate the transient policy is over
            #ifdef DEBUG
            printf("http-head-boot#http-head-cam-cloud-backward: State %hhu -> State 0\n", interactions_data[12].current_state);
            #endif
            interactions_data[12].current_state = 0;
            (interactions_data[12].counters + 2)->packet_count.is_initialized = false;
        }


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,http-head-boot#http-head-cam-cloud-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: http-head-boot#http-head-cam-cloud-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[12].mutex));
    // Policy websocket-sas-1#websocket-cam-sas-1-backward
    pthread_mutex_lock(&(interactions_data[17].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[17].current_state;
    #endif
    if (
        ( 
        interactions_data[17].current_state == 2
        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = src_addr}, interactions_data[17].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas-1.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = src_addr}) )
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,websocket-sas-1#websocket-cam-sas-1-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: websocket-sas-1#websocket-cam-sas-1-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[17].mutex));

    // Free memory allocated for parsed messages
    http_free_message(http_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,bootstrap-stream-wan#http-relay-cam-sas-1-backward,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief get-ip-address#dhcp-ack callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_get_ip_address_dhcp_ack(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_get_ip_address_dhcp_ack(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1080\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    // Skip layer 3 and 4 headers
    size_t skipped = get_headers_length(payload);

    // Parse payload as DHCP message
    dhcp_message_t dhcp_message = dhcp_parse_message(payload + skipped);
    #ifdef DEBUG
    dhcp_print_message(dhcp_message);
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy get-ip-address#dhcp-ack
    pthread_mutex_lock(&(interactions_data[11].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[11].current_state;
    #endif
    if (
        ( 
        interactions_data[11].current_state == 0
        )
        && (
        dhcp_message.options.message_type == DHCP_ACK
        &&
        strcmp(mac_hex_to_str(dhcp_message.chaddr), "b0:c5:54:43:54:83") == 0
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("get-ip-address#dhcp-ack: State %hhu -> State 1\n", interactions_data[11].current_state);
        #endif
        interactions_data[11].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,get-ip-address#dhcp-ack,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: get-ip-address#dhcp-ack - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[11].mutex));
    // Policy get-ip-address#dhcp-offer
    pthread_mutex_lock(&(interactions_data[11].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[11].current_state;
    #endif
    if (
        ( 
        interactions_data[11].current_state == 2
        )
        && (
        dhcp_message.options.message_type == DHCP_OFFER
        &&
        strcmp(mac_hex_to_str(dhcp_message.chaddr), "b0:c5:54:43:54:83") == 0
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("get-ip-address#dhcp-offer: State %hhu -> State 3\n", interactions_data[11].current_state);
        #endif
        interactions_data[11].current_state = 3;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,get-ip-address#dhcp-offer,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: get-ip-address#dhcp-offer - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[11].mutex));

    // Free memory allocated for parsed messages
    dhcp_free_message(dhcp_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,get-ip-address#dhcp-ack,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief get-ip-address#dhcp-discover callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_get_ip_address_dhcp_discover(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_get_ip_address_dhcp_discover(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1081\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    // Skip layer 3 and 4 headers
    size_t skipped = get_headers_length(payload);

    // Parse payload as DHCP message
    dhcp_message_t dhcp_message = dhcp_parse_message(payload + skipped);
    #ifdef DEBUG
    dhcp_print_message(dhcp_message);
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy get-ip-address#dhcp-discover
    pthread_mutex_lock(&(interactions_data[11].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[11].current_state;
    #endif
    if (
        ( 
        interactions_data[11].current_state == 1
        )
        && (
        dhcp_message.options.message_type == DHCP_DISCOVER
        &&
        strcmp(mac_hex_to_str(dhcp_message.chaddr), "b0:c5:54:43:54:83") == 0
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("get-ip-address#dhcp-discover: State %hhu -> State 2\n", interactions_data[11].current_state);
        #endif
        interactions_data[11].current_state = 2;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,get-ip-address#dhcp-discover,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: get-ip-address#dhcp-discover - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[11].mutex));
    // Policy get-ip-address#dhcp-request
    pthread_mutex_lock(&(interactions_data[11].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[11].current_state;
    #endif
    if (
        ( 
        interactions_data[11].current_state == 3
        )
        && (
        dhcp_message.options.message_type == DHCP_REQUEST
        &&
        strcmp(mac_hex_to_str(dhcp_message.chaddr), "b0:c5:54:43:54:83") == 0
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("get-ip-address#dhcp-request: State %hhu -> State 0\n", interactions_data[11].current_state);
        #endif
        interactions_data[11].current_state = 0;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,get-ip-address#dhcp-request,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: get-ip-address#dhcp-request - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[11].mutex));

    // Free memory allocated for parsed messages
    dhcp_free_message(dhcp_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,get-ip-address#dhcp-discover,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief https-boot-cam-fwd#https-cam-fwd callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_https_boot_cam_fwd_https_cam_fwd(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_https_boot_cam_fwd_https_cam_fwd(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1090\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t dst_addr = get_ipv4_dst_addr(payload);  // IPv4 destination address, in network byte order
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP

    // Initialize packet count if not initialized yet
    if (!(interactions_data[13].counters + 2)->packet_count.is_initialized) {
        (interactions_data[13].counters + 2)->packet_count.value = 0;
        (interactions_data[13].counters + 2)->packet_count.is_initialized = true;
    }

    // Policy https-boot-cam-fwd#https-cam-fwd
    pthread_mutex_lock(&(interactions_data[13].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[13].current_state;
    #endif
    if (
        (interactions_data[13].counters + 2)->packet_count.is_initialized &&
        ( 
        interactions_data[13].current_state == 2 ||
        interactions_data[13].current_state == 3
        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}, interactions_data[13].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-fwd.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}) )
        )
    ) {

        // Policy is transient, increment state to indicate the transient policy is ongoing
        #ifdef DEBUG
        printf("https-boot-cam-fwd#https-cam-fwd: State %hhu -> State 3\n", interactions_data[13].current_state);
        #endif
        interactions_data[13].current_state = 3;
        // Increment packet count
        (interactions_data[13].counters + 2)->packet_count.value++;
        if (
            (interactions_data[13].counters + 2)->packet_count.value >= 30
        ) {
            // Policy is transient and counters have been reached
            // Increment state to indicate the transient policy is over
            #ifdef DEBUG
            printf("https-boot-cam-fwd#https-cam-fwd: State %hhu -> State 0\n", interactions_data[13].current_state);
            #endif
            interactions_data[13].current_state = 0;
            (interactions_data[13].counters + 2)->packet_count.is_initialized = false;
        }


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,https-boot-cam-fwd#https-cam-fwd,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: https-boot-cam-fwd#https-cam-fwd - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[13].mutex));
    // Policy https-dcdda#https-cam-dcdda
    pthread_mutex_lock(&(interactions_data[14].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[14].current_state;
    #endif
    if (
        ( 
        interactions_data[14].current_state == 2        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}, interactions_data[14].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-dcdda.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}) )
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,https-dcdda#https-cam-dcdda,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: https-dcdda#https-cam-dcdda - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[14].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,https-boot-cam-fwd#https-cam-fwd,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief https-boot-cam-fwd#https-cam-fwd-backward callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_https_boot_cam_fwd_https_cam_fwd_backward(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_https_boot_cam_fwd_https_cam_fwd_backward(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1091\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t src_addr = get_ipv4_src_addr(payload);  // IPv4 source address, in network byte order
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy https-boot-cam-fwd#https-cam-fwd-backward
    pthread_mutex_lock(&(interactions_data[13].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[13].current_state;
    #endif
    if (
        (interactions_data[13].counters + 2)->packet_count.is_initialized &&
        ( 
        interactions_data[13].current_state == 2 ||
        interactions_data[13].current_state == 3
        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = src_addr}, interactions_data[13].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-fwd.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = src_addr}) )
        )
    ) {

        // Policy is transient, increment state to indicate the transient policy is ongoing
        #ifdef DEBUG
        printf("https-boot-cam-fwd#https-cam-fwd-backward: State %hhu -> State 3\n", interactions_data[13].current_state);
        #endif
        interactions_data[13].current_state = 3;
        // Increment packet count
        (interactions_data[13].counters + 2)->packet_count.value++;
        if (
            (interactions_data[13].counters + 2)->packet_count.value >= 30
        ) {
            // Policy is transient and counters have been reached
            // Increment state to indicate the transient policy is over
            #ifdef DEBUG
            printf("https-boot-cam-fwd#https-cam-fwd-backward: State %hhu -> State 0\n", interactions_data[13].current_state);
            #endif
            interactions_data[13].current_state = 0;
            (interactions_data[13].counters + 2)->packet_count.is_initialized = false;
        }


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,https-boot-cam-fwd#https-cam-fwd-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: https-boot-cam-fwd#https-cam-fwd-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[13].mutex));
    // Policy https-dcdda#https-cam-dcdda-backward
    pthread_mutex_lock(&(interactions_data[14].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[14].current_state;
    #endif
    if (
        ( 
        interactions_data[14].current_state == 2
        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = src_addr}, interactions_data[14].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-dcdda.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = src_addr}) )
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,https-dcdda#https-cam-dcdda-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: https-dcdda#https-cam-dcdda-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[14].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,https-boot-cam-fwd#https-cam-fwd-backward,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-external#stun-bind-cam-server callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_stun_bind_cam_server(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_stun_bind_cam_server(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1100\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t dst_addr = get_ipv4_dst_addr(payload);  // IPv4 destination address, in network byte order
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#stun-bind-cam-server
    pthread_mutex_lock(&(interactions_data[15].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[15].current_state;
    #endif
    if (
        ( 
        interactions_data[15].current_state == 4
        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}, interactions_data[15].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}) )
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#stun-bind-cam-server: State %hhu -> State 5\n", interactions_data[15].current_state);
        #endif
        interactions_data[15].current_state = 5;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#stun-bind-cam-server - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[15].mutex));
    // Policy stream-app-local#stun-bind-cam-server
    pthread_mutex_lock(&(interactions_data[16].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[16].current_state;
    #endif
    if (
        ( 
        interactions_data[16].current_state == 4
        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}, interactions_data[16].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}) )
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-local#stun-bind-cam-server: State %hhu -> State 5\n", interactions_data[16].current_state);
        #endif
        interactions_data[16].current_state = 5;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#stun-bind-cam-server,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-local#stun-bind-cam-server - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[16].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-external#stun-bind-cam-server-backward callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_stun_bind_cam_server_backward(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_stun_bind_cam_server_backward(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1101\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t src_addr = get_ipv4_src_addr(payload);  // IPv4 source address, in network byte order
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#stun-bind-cam-server-backward
    pthread_mutex_lock(&(interactions_data[15].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[15].current_state;
    #endif
    if (
        ( 
        interactions_data[15].current_state == 5
        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = src_addr}, interactions_data[15].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = src_addr}) )
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#stun-bind-cam-server-backward: State %hhu -> State 6\n", interactions_data[15].current_state);
        #endif
        interactions_data[15].current_state = 6;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#stun-bind-cam-server-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[15].mutex));
    // Policy stream-app-local#stun-bind-cam-server-backward
    pthread_mutex_lock(&(interactions_data[16].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[16].current_state;
    #endif
    if (
        ( 
        interactions_data[16].current_state == 5
        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = src_addr}, interactions_data[16].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = src_addr}) )
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-local#stun-bind-cam-server-backward: State %hhu -> State 6\n", interactions_data[16].current_state);
        #endif
        interactions_data[16].current_state = 6;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#stun-bind-cam-server-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-local#stun-bind-cam-server-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[16].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server-backward,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-external#udp-stream-wan callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_udp_stream_wan(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_udp_stream_wan(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1102\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#udp-stream-wan
    pthread_mutex_lock(&(interactions_data[15].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[15].current_state;
    #endif
    if (
        ( 
        interactions_data[15].current_state == 6        )
    ) {
        // Exit loop, update loop state
        if (interactions_data[15].in_loop) {
            interactions_data[15].in_loop = false;
            }



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#udp-stream-wan - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[15].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-external#udp-stream-wan-backward callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_udp_stream_wan_backward(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_udp_stream_wan_backward(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1103\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#udp-stream-wan-backward
    pthread_mutex_lock(&(interactions_data[15].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[15].current_state;
    #endif
    if (
        ( 
        interactions_data[15].current_state == 6
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#udp-stream-wan-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[15].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan-backward,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-local#udp-stream-lan callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_local_udp_stream_lan(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_local_udp_stream_lan(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1110\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-local#udp-stream-lan
    pthread_mutex_lock(&(interactions_data[16].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[16].current_state;
    #endif
    if (
        ( 
        interactions_data[16].current_state == 6        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#udp-stream-lan,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-local#udp-stream-lan - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[16].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#udp-stream-lan,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-local#udp-stream-lan-backward callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_local_udp_stream_lan_backward(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_local_udp_stream_lan_backward(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1111\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-local#udp-stream-lan-backward
    pthread_mutex_lock(&(interactions_data[16].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[16].current_state;
    #endif
    if (
        ( 
        interactions_data[16].current_state == 6
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#udp-stream-lan-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-local#udp-stream-lan-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[16].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-local#udp-stream-lan-backward,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief SIGINT handler, flush stdout and exit.
 *
 * @param arg unused
 */
void sigint_handler(int arg) {
    fflush(stdout);
    exit(0);
}

/**
 * @brief Program entry point
 * 
 * @param argc number of command line arguments
 * @param argv list of command line arguments
 * @return exit code, 0 if success
 */
int main(int argc, char const *argv[]) {

    // Setup SIGINT handler
    signal(SIGINT, sigint_handler);

    #ifdef LOG
    // CSV log file header
    printf("hash,timestamp,policy,state,verdict\n");
    #endif /* LOG */

    /* GLOBAL STRUCTURES INITIALIZATION */

    // Initialize DNS map
    dns_map = dns_map_create();


    /* INTERACTION DATA INITIALIZATION */

    int ret = 0;  // Return code for various functions
    interactions_data[0].nfq_id_base = 1000;
    interactions_data[0].num_policies = 2;
    interactions_data[0].num_states = 2;
    ret = pthread_mutex_init(&(interactions_data[0].mutex), NULL);
    assert(ret == 0);
    interactions_data[0].current_state = 0;
    interactions_data[0].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[0].counters = (counters_t *) malloc(sizeof(counters_t) * 2);
    assert(interactions_data[0].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 2; i++) {
        (interactions_data[0].counters + i)->packet_count.is_initialized = false;
        (interactions_data[0].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[0].in_loop = false;

    interactions_data[1].nfq_id_base = 1010;
    interactions_data[1].num_policies = 1;
    interactions_data[1].num_states = 1;
    ret = pthread_mutex_init(&(interactions_data[1].mutex), NULL);
    assert(ret == 0);
    interactions_data[1].current_state = 0;
    interactions_data[1].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[1].counters = (counters_t *) malloc(sizeof(counters_t) * 1);
    assert(interactions_data[1].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 1; i++) {
        (interactions_data[1].counters + i)->packet_count.is_initialized = false;
        (interactions_data[1].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[1].in_loop = false;

    interactions_data[2].nfq_id_base = 1020;
    interactions_data[2].num_policies = 1;
    interactions_data[2].num_states = 1;
    ret = pthread_mutex_init(&(interactions_data[2].mutex), NULL);
    assert(ret == 0);
    interactions_data[2].current_state = 0;
    interactions_data[2].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[2].counters = (counters_t *) malloc(sizeof(counters_t) * 1);
    assert(interactions_data[2].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 1; i++) {
        (interactions_data[2].counters + i)->packet_count.is_initialized = false;
        (interactions_data[2].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[2].in_loop = false;

    interactions_data[3].nfq_id_base = 1030;
    interactions_data[3].num_policies = 1;
    interactions_data[3].num_states = 1;
    ret = pthread_mutex_init(&(interactions_data[3].mutex), NULL);
    assert(ret == 0);
    interactions_data[3].current_state = 0;
    interactions_data[3].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[3].counters = (counters_t *) malloc(sizeof(counters_t) * 1);
    assert(interactions_data[3].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 1; i++) {
        (interactions_data[3].counters + i)->packet_count.is_initialized = false;
        (interactions_data[3].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[3].in_loop = false;

    interactions_data[4].nfq_id_base = 1030;
    interactions_data[4].num_policies = 1;
    interactions_data[4].num_states = 1;
    ret = pthread_mutex_init(&(interactions_data[4].mutex), NULL);
    assert(ret == 0);
    interactions_data[4].current_state = 0;
    interactions_data[4].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[4].counters = (counters_t *) malloc(sizeof(counters_t) * 1);
    assert(interactions_data[4].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 1; i++) {
        (interactions_data[4].counters + i)->packet_count.is_initialized = false;
        (interactions_data[4].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[4].in_loop = false;

    interactions_data[5].nfq_id_base = 1030;
    interactions_data[5].num_policies = 2;
    interactions_data[5].num_states = 0;
    ret = pthread_mutex_init(&(interactions_data[5].mutex), NULL);
    assert(ret == 0);
    interactions_data[5].current_state = 0;
    interactions_data[5].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[5].counters = (counters_t *) malloc(sizeof(counters_t) * 2);
    assert(interactions_data[5].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 2; i++) {
        (interactions_data[5].counters + i)->packet_count.is_initialized = false;
        (interactions_data[5].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[5].in_loop = false;

    interactions_data[6].nfq_id_base = 1030;
    interactions_data[6].num_policies = 2;
    interactions_data[6].num_states = 2;
    ret = pthread_mutex_init(&(interactions_data[6].mutex), NULL);
    assert(ret == 0);
    interactions_data[6].current_state = 0;
    interactions_data[6].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[6].counters = (counters_t *) malloc(sizeof(counters_t) * 2);
    assert(interactions_data[6].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 2; i++) {
        (interactions_data[6].counters + i)->packet_count.is_initialized = false;
        (interactions_data[6].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[6].in_loop = false;

    interactions_data[7].nfq_id_base = 1040;
    interactions_data[7].num_policies = 2;
    interactions_data[7].num_states = 2;
    ret = pthread_mutex_init(&(interactions_data[7].mutex), NULL);
    assert(ret == 0);
    interactions_data[7].current_state = 0;
    interactions_data[7].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[7].counters = (counters_t *) malloc(sizeof(counters_t) * 2);
    assert(interactions_data[7].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 2; i++) {
        (interactions_data[7].counters + i)->packet_count.is_initialized = false;
        (interactions_data[7].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[7].in_loop = false;

    interactions_data[8].nfq_id_base = 1050;
    interactions_data[8].num_policies = 2;
    interactions_data[8].num_states = 2;
    ret = pthread_mutex_init(&(interactions_data[8].mutex), NULL);
    assert(ret == 0);
    interactions_data[8].current_state = 0;
    interactions_data[8].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[8].counters = (counters_t *) malloc(sizeof(counters_t) * 2);
    assert(interactions_data[8].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 2; i++) {
        (interactions_data[8].counters + i)->packet_count.is_initialized = false;
        (interactions_data[8].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[8].in_loop = false;

    interactions_data[9].nfq_id_base = 1060;
    interactions_data[9].num_policies = 2;
    interactions_data[9].num_states = 2;
    ret = pthread_mutex_init(&(interactions_data[9].mutex), NULL);
    assert(ret == 0);
    interactions_data[9].current_state = 0;
    interactions_data[9].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[9].counters = (counters_t *) malloc(sizeof(counters_t) * 2);
    assert(interactions_data[9].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 2; i++) {
        (interactions_data[9].counters + i)->packet_count.is_initialized = false;
        (interactions_data[9].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[9].in_loop = false;

    interactions_data[10].nfq_id_base = 1070;
    interactions_data[10].num_policies = 6;
    interactions_data[10].num_states = 6;
    ret = pthread_mutex_init(&(interactions_data[10].mutex), NULL);
    assert(ret == 0);
    interactions_data[10].current_state = 0;
    interactions_data[10].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[10].counters = (counters_t *) malloc(sizeof(counters_t) * 6);
    assert(interactions_data[10].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 6; i++) {
        (interactions_data[10].counters + i)->packet_count.is_initialized = false;
        (interactions_data[10].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[10].in_loop = false;

    interactions_data[11].nfq_id_base = 1080;
    interactions_data[11].num_policies = 4;
    interactions_data[11].num_states = 4;
    ret = pthread_mutex_init(&(interactions_data[11].mutex), NULL);
    assert(ret == 0);
    interactions_data[11].current_state = 0;
    interactions_data[11].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[11].counters = (counters_t *) malloc(sizeof(counters_t) * 4);
    assert(interactions_data[11].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 4; i++) {
        (interactions_data[11].counters + i)->packet_count.is_initialized = false;
        (interactions_data[11].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[11].in_loop = false;

    interactions_data[12].nfq_id_base = 1090;
    interactions_data[12].num_policies = 4;
    interactions_data[12].num_states = 4;
    ret = pthread_mutex_init(&(interactions_data[12].mutex), NULL);
    assert(ret == 0);
    interactions_data[12].current_state = 0;
    interactions_data[12].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[12].counters = (counters_t *) malloc(sizeof(counters_t) * 4);
    assert(interactions_data[12].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 4; i++) {
        (interactions_data[12].counters + i)->packet_count.is_initialized = false;
        (interactions_data[12].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[12].in_loop = false;

    interactions_data[13].nfq_id_base = 1090;
    interactions_data[13].num_policies = 4;
    interactions_data[13].num_states = 4;
    ret = pthread_mutex_init(&(interactions_data[13].mutex), NULL);
    assert(ret == 0);
    interactions_data[13].current_state = 0;
    interactions_data[13].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[13].counters = (counters_t *) malloc(sizeof(counters_t) * 4);
    assert(interactions_data[13].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 4; i++) {
        (interactions_data[13].counters + i)->packet_count.is_initialized = false;
        (interactions_data[13].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[13].in_loop = false;

    interactions_data[14].nfq_id_base = 1100;
    interactions_data[14].num_policies = 4;
    interactions_data[14].num_states = 3;
    ret = pthread_mutex_init(&(interactions_data[14].mutex), NULL);
    assert(ret == 0);
    interactions_data[14].current_state = 0;
    interactions_data[14].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[14].counters = (counters_t *) malloc(sizeof(counters_t) * 4);
    assert(interactions_data[14].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 4; i++) {
        (interactions_data[14].counters + i)->packet_count.is_initialized = false;
        (interactions_data[14].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[14].in_loop = false;

    interactions_data[15].nfq_id_base = 1100;
    interactions_data[15].num_policies = 8;
    interactions_data[15].num_states = 7;
    ret = pthread_mutex_init(&(interactions_data[15].mutex), NULL);
    assert(ret == 0);
    interactions_data[15].current_state = 0;
    interactions_data[15].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[15].counters = (counters_t *) malloc(sizeof(counters_t) * 8);
    assert(interactions_data[15].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 8; i++) {
        (interactions_data[15].counters + i)->packet_count.is_initialized = false;
        (interactions_data[15].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[15].in_loop = false;

    interactions_data[16].nfq_id_base = 1110;
    interactions_data[16].num_policies = 8;
    interactions_data[16].num_states = 7;
    ret = pthread_mutex_init(&(interactions_data[16].mutex), NULL);
    assert(ret == 0);
    interactions_data[16].current_state = 0;
    interactions_data[16].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[16].counters = (counters_t *) malloc(sizeof(counters_t) * 8);
    assert(interactions_data[16].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 8; i++) {
        (interactions_data[16].counters + i)->packet_count.is_initialized = false;
        (interactions_data[16].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[16].in_loop = false;

    interactions_data[17].nfq_id_base = 1120;
    interactions_data[17].num_policies = 4;
    interactions_data[17].num_states = 3;
    ret = pthread_mutex_init(&(interactions_data[17].mutex), NULL);
    assert(ret == 0);
    interactions_data[17].current_state = 0;
    interactions_data[17].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[17].counters = (counters_t *) malloc(sizeof(counters_t) * 4);
    assert(interactions_data[17].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 4; i++) {
        (interactions_data[17].counters + i)->packet_count.is_initialized = false;
        (interactions_data[17].counters + i)->duration.is_initialized = false;
    }
    // Set in_loop states to false
    interactions_data[17].in_loop = false;


    
    /* NFQUEUE THREADS LAUNCH */

    // Create threads
    uint8_t i = 0;

    // single_dns_ipv4
    thread_arg_t thread_arg_single_dns_ipv4 = {
        .queue_id = 1000,
        .func = &callback_single_dns_ipv4,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_single_dns_ipv4);
    assert(ret == 0);
    
    // single_dns_ipv4_backward
    thread_arg_t thread_arg_single_dns_ipv4_backward = {
        .queue_id = 1001,
        .func = &callback_single_dns_ipv4_backward,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_single_dns_ipv4_backward);
    assert(ret == 0);
    
    // single_igmp_join_mdns
    thread_arg_t thread_arg_single_igmp_join_mdns = {
        .queue_id = 1010,
        .func = &callback_single_igmp_join_mdns,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_single_igmp_join_mdns);
    assert(ret == 0);
    
    // single_mdns_query_any
    thread_arg_t thread_arg_single_mdns_query_any = {
        .queue_id = 1020,
        .func = &callback_single_mdns_query_any,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_single_mdns_query_any);
    assert(ret == 0);
    
    // arp_cam_gateway_arp_reply_gateway_cam
    thread_arg_t thread_arg_arp_cam_gateway_arp_reply_gateway_cam = {
        .queue_id = 1030,
        .func = &callback_arp_cam_gateway_arp_reply_gateway_cam,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_arp_cam_gateway_arp_reply_gateway_cam);
    assert(ret == 0);
    
    // arp_cam_gateway_arp_request_cam_gateway
    thread_arg_t thread_arg_arp_cam_gateway_arp_request_cam_gateway = {
        .queue_id = 1031,
        .func = &callback_arp_cam_gateway_arp_request_cam_gateway,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_arp_cam_gateway_arp_request_cam_gateway);
    assert(ret == 0);
    
    // arp_camera_phone_arp_reply_phone_cam
    thread_arg_t thread_arg_arp_camera_phone_arp_reply_phone_cam = {
        .queue_id = 1040,
        .func = &callback_arp_camera_phone_arp_reply_phone_cam,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_arp_camera_phone_arp_reply_phone_cam);
    assert(ret == 0);
    
    // arp_camera_phone_arp_request_cam_phone
    thread_arg_t thread_arg_arp_camera_phone_arp_request_cam_phone = {
        .queue_id = 1041,
        .func = &callback_arp_camera_phone_arp_request_cam_phone,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_arp_camera_phone_arp_request_cam_phone);
    assert(ret == 0);
    
    // arp_gateway_cam_arp_reply_cam_gateway
    thread_arg_t thread_arg_arp_gateway_cam_arp_reply_cam_gateway = {
        .queue_id = 1050,
        .func = &callback_arp_gateway_cam_arp_reply_cam_gateway,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_arp_gateway_cam_arp_reply_cam_gateway);
    assert(ret == 0);
    
    // arp_gateway_cam_arp_request_gateway_cam
    thread_arg_t thread_arg_arp_gateway_cam_arp_request_gateway_cam = {
        .queue_id = 1051,
        .func = &callback_arp_gateway_cam_arp_request_gateway_cam,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_arp_gateway_cam_arp_request_gateway_cam);
    assert(ret == 0);
    
    // arp_phone_camera_arp_reply_cam_phone
    thread_arg_t thread_arg_arp_phone_camera_arp_reply_cam_phone = {
        .queue_id = 1060,
        .func = &callback_arp_phone_camera_arp_reply_cam_phone,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_arp_phone_camera_arp_reply_cam_phone);
    assert(ret == 0);
    
    // arp_phone_camera_arp_request_phone_cam
    thread_arg_t thread_arg_arp_phone_camera_arp_request_phone_cam = {
        .queue_id = 1061,
        .func = &callback_arp_phone_camera_arp_request_phone_cam,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_arp_phone_camera_arp_request_phone_cam);
    assert(ret == 0);
    
    // bootstrap_stream_wan_http_relay_cam_sas_1
    thread_arg_t thread_arg_bootstrap_stream_wan_http_relay_cam_sas_1 = {
        .queue_id = 1070,
        .func = &callback_bootstrap_stream_wan_http_relay_cam_sas_1,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_bootstrap_stream_wan_http_relay_cam_sas_1);
    assert(ret == 0);
    
    // bootstrap_stream_wan_http_relay_cam_sas_1_backward
    thread_arg_t thread_arg_bootstrap_stream_wan_http_relay_cam_sas_1_backward = {
        .queue_id = 1071,
        .func = &callback_bootstrap_stream_wan_http_relay_cam_sas_1_backward,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_bootstrap_stream_wan_http_relay_cam_sas_1_backward);
    assert(ret == 0);
    
    // get_ip_address_dhcp_ack
    thread_arg_t thread_arg_get_ip_address_dhcp_ack = {
        .queue_id = 1080,
        .func = &callback_get_ip_address_dhcp_ack,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_get_ip_address_dhcp_ack);
    assert(ret == 0);
    
    // get_ip_address_dhcp_discover
    thread_arg_t thread_arg_get_ip_address_dhcp_discover = {
        .queue_id = 1081,
        .func = &callback_get_ip_address_dhcp_discover,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_get_ip_address_dhcp_discover);
    assert(ret == 0);
    
    // https_boot_cam_fwd_https_cam_fwd
    thread_arg_t thread_arg_https_boot_cam_fwd_https_cam_fwd = {
        .queue_id = 1090,
        .func = &callback_https_boot_cam_fwd_https_cam_fwd,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_https_boot_cam_fwd_https_cam_fwd);
    assert(ret == 0);
    
    // https_boot_cam_fwd_https_cam_fwd_backward
    thread_arg_t thread_arg_https_boot_cam_fwd_https_cam_fwd_backward = {
        .queue_id = 1091,
        .func = &callback_https_boot_cam_fwd_https_cam_fwd_backward,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_https_boot_cam_fwd_https_cam_fwd_backward);
    assert(ret == 0);
    
    // stream_app_external_stun_bind_cam_server
    thread_arg_t thread_arg_stream_app_external_stun_bind_cam_server = {
        .queue_id = 1100,
        .func = &callback_stream_app_external_stun_bind_cam_server,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_stun_bind_cam_server);
    assert(ret == 0);
    
    // stream_app_external_stun_bind_cam_server_backward
    thread_arg_t thread_arg_stream_app_external_stun_bind_cam_server_backward = {
        .queue_id = 1101,
        .func = &callback_stream_app_external_stun_bind_cam_server_backward,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_stun_bind_cam_server_backward);
    assert(ret == 0);
    
    // stream_app_external_udp_stream_wan
    thread_arg_t thread_arg_stream_app_external_udp_stream_wan = {
        .queue_id = 1102,
        .func = &callback_stream_app_external_udp_stream_wan,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_udp_stream_wan);
    assert(ret == 0);
    
    // stream_app_external_udp_stream_wan_backward
    thread_arg_t thread_arg_stream_app_external_udp_stream_wan_backward = {
        .queue_id = 1103,
        .func = &callback_stream_app_external_udp_stream_wan_backward,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_udp_stream_wan_backward);
    assert(ret == 0);
    
    // stream_app_local_udp_stream_lan
    thread_arg_t thread_arg_stream_app_local_udp_stream_lan = {
        .queue_id = 1110,
        .func = &callback_stream_app_local_udp_stream_lan,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_local_udp_stream_lan);
    assert(ret == 0);
    
    // stream_app_local_udp_stream_lan_backward
    thread_arg_t thread_arg_stream_app_local_udp_stream_lan_backward = {
        .queue_id = 1111,
        .func = &callback_stream_app_local_udp_stream_lan_backward,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_local_udp_stream_lan_backward);
    assert(ret == 0);
    
    // Wait forever for threads
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }


    /* FREE MEMORY */

    // Free interactions data
    for (uint8_t i = 0; i < NUM_INTERACTIONS; i++) {
        free(interactions_data[i].counters);
        pthread_mutex_destroy(&(interactions_data[i].mutex));
    }

    // Free DNS map
    dns_map_free(dns_map);

    return 0;
}
