// THIS FILE HAS BEEN AUTOGENERATED. DO NOT EDIT.

/**
 * Nefilter queue for device dlink-cam
 */

// Standard libraries
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <pthread.h>
#include <assert.h>
#include <signal.h>
#include <sys/time.h>
// Custom libraries
#include "nfqueue.h"
#include "packet_utils.h"
#include "rule_utils.h"
// Parsers
#include "parsers/header.h"
#include "parsers/dns.h"

// Constants
#define NUM_INTERACTIONS 1
#define NUM_THREADS 6

interaction_data_t interactions_data[NUM_INTERACTIONS];
pthread_t threads[NUM_THREADS];

dns_map_t *dns_map;  // Domain name to IP address mapping

#ifdef DEBUG
uint16_t accepted_packets = 0;
#endif /* DEBUG */
/**
 * @brief stream-app-external#dns-cam-server-a callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_dns_cam_server_a(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_dns_cam_server_a(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1000\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    // Skip layer 3 and 4 headers
    size_t skipped = get_headers_length(payload);

    // Parse payload as DNS message
    dns_message_t dns_message = dns_parse_message(payload + skipped);
    #ifdef DEBUG
    dns_print_message(dns_message);
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#dns-cam-server-a
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        ( 


        interactions_data[0].current_state == 3 ||
        interactions_data[0].current_state == 0
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == A )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#dns-cam-server-a: State %hhu -> State 1\n", interactions_data[0].current_state);
        #endif
        interactions_data[0].current_state = 1;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-a,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#dns-cam-server-a - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));
    // Policy stream-app-external#dns-cam-server-aaaa
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        ( 
        (
        interactions_data[0].in_loop && 
        interactions_data[0].current_state == 3
        ) ||


        interactions_data[0].current_state == 1
        )
        && (
        dns_message.header.qr == 0
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {
        // Enter loop, update loop state
        interactions_data[0].in_loop = true;

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#dns-cam-server-aaaa: State %hhu -> State 2\n", interactions_data[0].current_state);
        #endif
        interactions_data[0].current_state = 2;


        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-aaaa,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#dns-cam-server-aaaa - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));

    // Free memory allocated for parsed messages
    dns_free_message(dns_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-a,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-external#dns-cam-server-aaaa-backward callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_dns_cam_server_aaaa_backward(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_dns_cam_server_aaaa_backward(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1001\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    // Skip layer 3 and 4 headers
    size_t skipped = get_headers_length(payload);

    // Parse payload as DNS message
    dns_message_t dns_message = dns_parse_message(payload + skipped);
    #ifdef DEBUG
    dns_print_message(dns_message);
    #endif
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#dns-cam-server-aaaa-backward
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        ( 


        interactions_data[0].current_state == 2
        )
        && (
        dns_message.header.qr == 1
        &&
        ( dns_message.header.qdcount > 0 && dns_message.questions->qtype == AAAA )
        &&
        dns_contains_full_domain_name(dns_message.questions, dns_message.header.qdcount, "mp-eu-sas.auto.mydlink.com")
        )
    ) {
        // Retrieve IP addresses corresponding to the given domain name from the DNS response
        char *domain_name = NULL;
        ip_list_t ip_list = ip_list_init();
        domain_name = "mp-eu-sas.auto.mydlink.com";
        ip_list = dns_get_ip_from_name(dns_message.answers, dns_message.header.ancount, domain_name);

        // Policy is one-off, increment state
        #ifdef DEBUG
        printf("stream-app-external#dns-cam-server-aaaa-backward: State %hhu -> State 3\n", interactions_data[0].current_state);
        #endif
        interactions_data[0].current_state = 3;

        if (ip_list.ip_count > 0) {
            // Add IP addresses to DNS map
            dns_map_add(dns_map, domain_name, ip_list);
            // Cache first IP address for quicker access
            interactions_data[0].cached_ip = *(ip_list.ip_addresses);
        }

        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-aaaa-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#dns-cam-server-aaaa-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));

    // Free memory allocated for parsed messages
    dns_free_message(dns_message);

    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#dns-cam-server-aaaa-backward,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-external#stun-bind-cam-server callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_stun_bind_cam_server(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_stun_bind_cam_server(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1002\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t dst_addr = get_ipv4_dst_addr(payload);  // IPv4 destination address, in network byte order
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#stun-bind-cam-server
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        ( 


        interactions_data[0].current_state == 3        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}, interactions_data[0].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = dst_addr}) )
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#stun-bind-cam-server - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-external#stun-bind-cam-server-backward callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_stun_bind_cam_server_backward(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_stun_bind_cam_server_backward(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1003\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t src_addr = get_ipv4_src_addr(payload);  // IPv4 source address, in network byte order
    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#stun-bind-cam-server-backward
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        ( 


        interactions_data[0].current_state == 3        )
        && (
        ( compare_ip((ip_addr_t) {.version = 4, .value.ipv4 = src_addr}, interactions_data[0].cached_ip) || dns_entry_contains(dns_map_get(dns_map, "mp-eu-sas.auto.mydlink.com"), (ip_addr_t) {.version = 4, .value.ipv4 = src_addr}) )
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#stun-bind-cam-server-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#stun-bind-cam-server-backward,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-external#udp-stream-wan callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_udp_stream_wan(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_udp_stream_wan(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1004\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#udp-stream-wan
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        ( 


        interactions_data[0].current_state == 3        )
    ) {
        // Exit loop, update loop state
        if (interactions_data[0].in_loop) {
            interactions_data[0].in_loop = false;
            }



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#udp-stream-wan - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief stream-app-external#udp-stream-wan-backward callback function, called when a packet enters the queue.
 * 
 * @param pkt_id packet ID for netfilter queue
 * @param hash packet payload SHA256 hash (only present if LOG is defined)
 * @param timestamp packet timestamp (only present if LOG is defined)
 * @param pkt_len packet length, in bytes
 * @param payload pointer to the packet payload
 * @param arg pointer to the argument passed to the callback function
 * @return the verdict for the packet
 */

#ifdef LOG
uint32_t callback_stream_app_external_udp_stream_wan_backward(int pkt_id, uint8_t *hash, struct timeval timestamp, int pkt_len, uint8_t *payload, void *arg)
#else
uint32_t callback_stream_app_external_udp_stream_wan_backward(int pkt_id, int pkt_len, uint8_t *payload, void *arg)
#endif /* LOG */
{
    #if defined DEBUG || defined LOG
    #ifdef DEBUG
    printf("Received packet from nfqueue 1005\n");
    #endif
    uint8_t previous_state;
    #endif /* DEBUG || LOG */

    uint32_t verdict = NF_DROP; // Packet verdict: STOP (accept) or DROP


    // Policy stream-app-external#udp-stream-wan-backward
    pthread_mutex_lock(&(interactions_data[0].mutex));
    #if defined DEBUG || defined LOG
    previous_state = interactions_data[0].current_state;
    #endif
    if (
        ( 


        interactions_data[0].current_state == 2 ||
        interactions_data[0].current_state == 3
        )
    ) {



        #ifdef LOG
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan-backward,%hhu,ACCEPT\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec, previous_state);
        #endif /* LOG */
        #ifdef DEBUG
        printf("ACCEPT - Policy: stream-app-external#udp-stream-wan-backward - State: %hhu\n", previous_state);
        if (verdict != NF_STOP) {
            accepted_packets++;
            printf("Accepted packets: %hu\n", accepted_packets);
        }
        #endif /* DEBUG */

        verdict = NF_STOP;

    }
    pthread_mutex_unlock(&(interactions_data[0].mutex));


    #ifdef LOG
    if (verdict != NF_STOP) {
        // Log packet as dropped
        print_hash(hash);
        printf(",%ld.%06ld,stream-app-external#udp-stream-wan-backward,,DROP\n", (long int)timestamp.tv_sec, (long int)timestamp.tv_usec);
    }
    free(hash);
    #endif /* LOG */

    return verdict;
}



/**
 * @brief SIGINT handler, flush stdout and exit.
 *
 * @param arg unused
 */
void sigint_handler(int arg) {
    fflush(stdout);
    exit(0);
}

/**
 * @brief Program entry point
 * 
 * @param argc number of command line arguments
 * @param argv list of command line arguments
 * @return exit code, 0 if success
 */
int main(int argc, char const *argv[]) {

    // Setup SIGINT handler
    signal(SIGINT, sigint_handler);

    #ifdef LOG
    // CSV log file header
    printf("hash,timestamp,policy,state,verdict\n");
    #endif /* LOG */

    /* GLOBAL STRUCTURES INITIALIZATION */

    // Initialize DNS map
    dns_map = dns_map_create();


    /* INTERACTION DATA INITIALIZATION */

    int ret = 0;  // Return code for various functions
    interactions_data[0].nfq_id_base = 1000;
    interactions_data[0].num_policies = 7;
    interactions_data[0].num_states = 4;
    ret = pthread_mutex_init(&(interactions_data[0].mutex), NULL);
    assert(ret == 0);
    interactions_data[0].current_state = 0;
    interactions_data[0].cached_ip = (ip_addr_t) {.version = 0, .value.ipv4 = 0};
    // Allocate memory for counters
    interactions_data[0].counters = (counters_t *) malloc(sizeof(counters_t) * 7);
    assert(interactions_data[0].counters != NULL);
    // Set counters states to uninitialized
    for (uint8_t i = 0; i < 7; i++) {
        (interactions_data[0].counters + i)->packet_count.is_initialized = false;
        (interactions_data[0].counters + i)->duration.is_initialized = false;
    }


    
    /* NFQUEUE THREADS LAUNCH */

    // Create threads
    uint8_t i = 0;

    // stream_app_external_dns_cam_server_a
    thread_arg_t thread_arg_stream_app_external_dns_cam_server_a = {
        .queue_id = 1000,
        .func = &callback_stream_app_external_dns_cam_server_a,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_dns_cam_server_a);
    assert(ret == 0);
    
    // stream_app_external_dns_cam_server_aaaa_backward
    thread_arg_t thread_arg_stream_app_external_dns_cam_server_aaaa_backward = {
        .queue_id = 1001,
        .func = &callback_stream_app_external_dns_cam_server_aaaa_backward,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_dns_cam_server_aaaa_backward);
    assert(ret == 0);
    
    // stream_app_external_stun_bind_cam_server
    thread_arg_t thread_arg_stream_app_external_stun_bind_cam_server = {
        .queue_id = 1002,
        .func = &callback_stream_app_external_stun_bind_cam_server,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_stun_bind_cam_server);
    assert(ret == 0);
    
    // stream_app_external_stun_bind_cam_server_backward
    thread_arg_t thread_arg_stream_app_external_stun_bind_cam_server_backward = {
        .queue_id = 1003,
        .func = &callback_stream_app_external_stun_bind_cam_server_backward,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_stun_bind_cam_server_backward);
    assert(ret == 0);
    
    // stream_app_external_udp_stream_wan
    thread_arg_t thread_arg_stream_app_external_udp_stream_wan = {
        .queue_id = 1004,
        .func = &callback_stream_app_external_udp_stream_wan,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_udp_stream_wan);
    assert(ret == 0);
    
    // stream_app_external_udp_stream_wan_backward
    thread_arg_t thread_arg_stream_app_external_udp_stream_wan_backward = {
        .queue_id = 1005,
        .func = &callback_stream_app_external_udp_stream_wan_backward,
        .arg = NULL
    };
    ret = pthread_create(&threads[i++], NULL, nfqueue_thread, (void *) &thread_arg_stream_app_external_udp_stream_wan_backward);
    assert(ret == 0);
    
    // Wait forever for threads
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }


    /* FREE MEMORY */

    // Free interactions data
    for (uint8_t i = 0; i < NUM_INTERACTIONS; i++) {
        free(interactions_data[i].counters);
        pthread_mutex_destroy(&(interactions_data[i].mutex));
    }

    // Free DNS map
    dns_map_free(dns_map);

    return 0;
}
